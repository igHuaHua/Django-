1.迭代器与生成器的区别
*首先认识一下什么叫可迭代对象：若一个类想要成为可迭代对象，即里面的元素能够一个一个取，
内部一定实现了__iter__方法

*迭代器：遵循迭代器协议，类必须有__iter__,__next__方法

*迭代器有效性：任何插入操作都将损坏Dict,Set迭代器,
               迭代器一旦耗尽，便不再可以使用，即使继续往容器中增加元素也不行
               尾插入操作不会损坏指向当前元素的List迭代器
               尾插入操作会损坏List尾迭代器，即List变长后，迭代器的终点也随之变化，即原先的尾迭代器将不再适用
               
*for循环就是基于迭代器协议提供了一个统一的可以遍历所有对象的方法，
即在遍历之前，先调用对象的__iter__方法将其转换成一个迭代器，
然后使用迭代器协议去实现循环访问

*生成器：
--是Python特有的一组特殊语法，主要目的是提供一个基于函数而不是类的迭代器定义方式

--生成器函数：常规函数定义，但是使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行

--生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表

--本质：迭代器

--特点：惰性运算，开发者自定义

--使用生成器的优点：延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。

相关面试题：
--
def demo():
    for i in range(4):
        yield i

g=demo()

g1=(i for i in g)
g2=(i for i in g1)

print(list(g1))#[0,1,2,3]   此时print(g1)是生成器对象，用list调用生成器next方法取值
print(list(g2))#[]  由于g1值被取完了，所以为空


--
def add(n,i):
    return n+i

def test():
    for i in range(4):
        yield i

g=test()
for n in [1,10]:
    g=(add(n,i) for i in g)

print(list(g))#[20, 21, 22, 23]    n = 10：g = (add(n,i) for i in (add(n,i) for i in test()))

*闭包跟装饰器

--什么是闭包

def f(name):
    def g():
        print(name)
    return g
这个函数内含还有一个函数，并且这个内嵌函数使用了外部函数的变量，外部函数返回值是内部函数的引用，这种函数被称为闭包。
跟普通函数不同的是，内嵌函数g()用了外部变量name，使外部变量生命周期被延长了。
变量生命周期被延长是因为闭包会使用python中一个魔法属性__closure__，它负责把外部变量生命周期延长
--装饰器
实质上是闭包的实现
--多个装饰器执行顺序
由外到内，逐层返回

*重载
--函数重载主要是为了解决两个问题：
    可变参数类型和可变参数个数
    对于可变参数类型，python能接受任意类型的变量
    对于可变参数个数，python可以用缺省参数解决
    所以python不需要重载
  

  
    
*单下划线和双下滑线的区别
1、前后都有双下划线-特殊变量
变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名
2、前面双下划线-私有变量
在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，连子类对象都不能访问。
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_${classname}__name，所以，仍然可以通过_${classname}__name来访问__name变量。但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名
3、前面单下划线-口头私有变量
以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，不能通过import导入，但是，
按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 



*@property的作用
既能检查参数是否符合要求，又能用类似属性的方法访问类的变量
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
    # 若没有定义setter方法，就是只读属性




  
   
*新式类&经典类
--新式类
    创建时继承内置object对象，经典类是直接声明的，python3里全部都是新式类
--内置object对象
1. __new__，__init__方法
这两个方法是用来创建object的子类对象，静态方法__new__()用来创建类的实例，然后再调用
__init__()来初始化实例。
 
2. __delattr__, __getattribute__, __setattr__方法
对象使用这些方法来处理属性的访问
 
3. __hash__, __repr__, __str__方法
print(someobj)会调用someobj.__str__()， 如果__str__没有定义，则会调用someobj.__repr__()，
 
 
 
__str__()和__repr__()的区别：

默认的实现是没有任何作用的
__repr__的目标是对象信息唯一性
__str__的目标是对象信息的可读性
容器对象的__str__一般使用的是对象元素的__repr__
如果重新定义了__repr__，而没有定义__str__，则默认调用__str__时，调用的是__repr__
也就是说好的编程习惯是每一个类都需要重写一个__repr__方法，用于提供对象的可读信息，
而重写__str__方法是可选的。实现__str__方法，一般是需要更加好看的打印效果，比如你要制作
一个报表的时候等。
可以允许object的子类重载这些方法，或者添加新的方法。


*__new__，__init__方法

--__new__用来创建类的实例
    利用__new__实现单例模式：
    class Singleton(object):
        _singletons = {}
        def __new__(cls):
            if not cls._singletons.has_key(cls):            #若还没有任何实例
                cls._singletons[cls] = object.__new__(cls)  #生成一个实例
            return cls._singletons[cls]                             #返回这个实例

*__slots__
python有个强大的功能，就是可以给实例动态绑定方法和属性，但是我们如果想要限制实例的属性该怎么办？
定义一个__slots__变量，只允许绑定name的对象：
                        class Student(object):
                            __slots__ = ('name')
但是这个方法对子类无效，除非子类自己定义一个__slots__



* MRO(Method Resolution Order， 方法解析顺序)
--经典类，从左到右，深度优先
--新式类，从左到右，广度优先


*单例模式的几种实现方式
--装饰器版本：
借助装饰器，开辟一个独立的命名空间，存放一个instance字典，在每次实例化的时候，会查看命名空间里有没有类实例，如果没有就创建，返回这个实例
    def singleton(cls):
        instances = {}
        def getinstance(*args, **kw):
            if cls not in instances:
                instances[cls] = cls(*args, **kw)
            return instances[cls]
        return getinstance

    @singleton
    class MyClass:
      ...

--使用__new__方法:
这里运用了反射，只要是继承了单例类的类，第一次实例化的时候都会调用父类（即Singleton）的构造方法（__new__),
然而可以看到在Singleton的new方法里，又调用了自己的父类即object的new方法并返回了一个类实例，作为单例。
其主要的思想就是类的实例化可以有任意次，但是父类只有一个且父类包含的方法和变量不会随着子类的实例化进行重置，这里可以通过dir()查看实例化子类前后方法的变化，
可以看出多出了个_instance属性
但是这里有个问题就是多线程中无法保证数据的安全，解决方法是加锁
    class Singleton(object):
        def __new__(cls, *args, **kw):
            if not hasattr(cls, '_instance'):
                orig = super(Singleton, cls)
                cls._instance = orig.__new__(cls, *args, **kw)
            return cls._instance

    class MyClass(Singleton):
        a = 1
    改进版：
        import threading
        class Singleton(object):
            _instance_lock = threading.Lock()   # 加锁
            def __new__(cls, *args, **kw):
                if not hasattr(cls, '_instance'):       # 这里进行判断是为了优化创建单例模式后，重复取锁，直接返回类实例即可
                    with _instance_lock:
                        if not hasattr(cls, '_instance'):
                            orig = super(Singleton, cls)
                            cls._instance = orig.__new__(cls, *args, **kw)
                return cls._instance


--共享属性
创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法.

    class Borg(object):
        _state = {}
        def __new__(cls, *args, **kw):
            ob = super(Borg, cls).__new__(cls, *args, **kw)
            ob.__dict__ = cls._state
            return ob

    class MyClass2(Borg):
        a = 1

--import方法
    作为python的模块是天然的单例模式

    # mysingleton.py
    class My_Singleton(object):
        def foo(self):
            pass

    my_singleton = My_Singleton()

    # to use
    from mysingleton import my_singleton

    my_singleton.foo()


*python中的作用域
--  Python中一个变量的作用域总是由在代码中被赋值的地方所决定的。

    当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：

    本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）

*GIL线程全局锁
Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，
但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。


--这里了解一下并行并发的区别
    并行：多个进程在同一时刻运行
    并发：多个进程在同一时间间隔运行
GIL锁并不意味着多线程是CPython的禁区，对于IO密集型任务，线程会在发生阻塞时主动释放GIL，以便
其他线程得以执行，而对于计算密集型任务采用超时策略，即当GIL被其他线程占用时，等待线程
会阻塞一段时间，如果超时后，依然无法取锁，则发出请求，设置一个全局条件变量，正在执行的线程
在解释循环内会检查该标记，然后释放锁，自身进入等待状态。
虽然GIL的存在让多线程无法并行，但依然可以实现多任务并发
对于计算密集型任务，除使用多进程架构外，还可以用C来编写多进程扩展，以绕开解释器的限制



*Python垃圾回收机制（引用计数为主，分代回收为辅）
--引用计数(可能会导致循环技术，导致内存泄漏)
在源码中，每个对象头部都有一个引用计数器，引用该对象时，技术增加，反之减小。
当计数归零时，立即调用回收函数清理并释放内存，对计数的操作，用两个宏函数实现。
但是这两个东西非常麻烦，一旦出错或者忘记调用，要么计数无法归零导致内存泄漏，
要么忘记增加计数让对象提前回收，另外，它还会引发内存管理问题，对象在传递过程中，
即便内容未被修改，可引用计数依然让其内存发生了变动，这可能会导致CPU缓存错失率提升，甚至让
写时复制（Copy-on-write）机制失效。
--标记-清除机制（此机制是解决循环引用的关键步骤）
基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，
遍历以对象为节点、以引用为边构成的图，
把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
--内存泄漏
不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。
通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息, 也可以通过 sys.getrefcount(obj) 来获取对象的引用计数, 并根据返回值是否为 0 来判断是否内存泄漏。
--分代技术
分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，
每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。
Python默认定义了三代对象集合，索引数越大，对象存活时间越长。
举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，
我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。
当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，
而对集合A进行垃圾回收要隔相当长一段时间后才进行，
这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，
集合B中的某些内存块由于存活时间长而会被转移到集合A中，
当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。

--内存池机制
在Python中, 大多数申请的都是小块的内存, 会执行大量的malloc和free操作。
Python引入了一个内存池机制, 用于管理对小块内存的申请和释放, 即Pymalloc机制。它将不用的内存放到内存池而不是返回给操作系统。
当申请的内存小于256字节时, PyObject_Malloc会在内存池中申请内存; 
当申请的内存大于256字节时, PyObject_Malloc的行为将蜕化为malloc的果你分配又释放了大量的整数, 用于缓存这些整数的内存就不能再分配给浮点数。
行为。
当然, 通过修改Python源代码, 我们可以改变这个默认值, 从而改变Python的默认内存管理行为。
对于Python对象, 如整数, 浮点数和List, 都有其独立的私有内存池, 对象间不共享他们的内存池。也就是说如



--python实现多线程同步

参考文章：https://cloud.tencent.com/developer/article/1083298

事实上，GIL线程全局锁并能一定保证数据安全，因为当时间轮转片要求切换到其它线程，但当前线程数据还没处理完成时，就会造成数据不安全
给线程加锁
Lock()：互斥锁。当存在两个锁以上的时候，可能会造成死锁问题（科学家吃面）
Rlock()：递归锁，相当于一串钥匙，当执行代码的时候，只有拿到这一串钥匙的线程才有权访问数据，释放的时候要释放多次锁，释放完其他线程才有机会拿到锁






--阅读GIL源码

*操作系统

---进程，线程，协程
进程是操作系统分配资源的最小单元，线程是操作系统可调度的最小单元
一个进程可包含多个线程
每个进程执行过程中拥有独立得到内存单元，而一个进程的多个线程在执行过程中共享内存
所以线程数据并不安全，Cpython采用了GIL锁机制来保证线程安全，但会损失一定的执行效率
join()方法就是为了让母进程/线程阻塞，等待子进程都完成
默认主进程会等待所有的子进程执行完成程序再退出,设置守护主进程后，
子进程会在主进程退出后直接销毁：当前子进程名.daemon = True
进程池/线程池
创建进程池：进程池名 = multiprossing.Pool(最大进程数)，提示：使用进程池创建的进程是守护主进程的状态，默认自己通过Process创建的进程是：不守护主进程的状态
选择同步或异步执行任务
同步（一个任务执行完后，另一个任务才执行）：进程池名.apply(函数名)
异步（任务执行不会等待，多个任务一起执行）：进程池名.apply_async(函数名）

--协程
对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，
这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，
让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。

协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案：

#1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。
#2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换

特点：
必须在只有一个单线程里实现并发
修改共享数据不需加锁
用户程序里自己保存多个控制流的上下文栈
附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））


--select poll epoll

(1)select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，
此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  

epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现

select：

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。

      一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.
2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：
当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
     
3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大

poll：

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，
如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。
它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：
1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   
2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

epoll:
epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，
提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，
read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。
还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

epoll为什么要有EPOLLET触发模式？
如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。
而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。
如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！
这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符



Redis有序列表底层实现




Redis集群哨兵机制




一条SQL执行流程（微信收藏）




登录注册系统怎么做？
分布式session问题

怎样解决redis和数据库一致性的问题（手机收藏）
分布式事务









--进程切换为什么开销大
进程切换分两步：

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。
这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，
这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。
--Linux中常见面试题





基本上都是一些面试常问到的题目

1、说一些你比较常用linux指令

　　1.1、ls/ll、cd、mkdir、rm-rf、cp、mv、ps -ef | grep xxx、kill、free-m、tar -xvf file.tar、（说那么十几二十来个估计差不多了）

2、查看进程（例：如何查看所有xx进程）

　　2.1、ps -ef | grep xxx

　　2.2、ps -aux | grep xxx（-aux显示所有状态）

3、杀掉进程

　　3.1、kill  -9[PID]    ---(PID用查看进程的方式查找)

4、启动/停止服务

　　4.1、cd到bin目录cd/

　　4.2、./startup.sh   --打开（先确保有足够的权限）

　　4.3、./shutdown.sh  ---关闭

5、查看日志

　　5.1、cd到服务器的logs目录（里面有xx.out文件）

　　5.2、tail -f xx.out  --此时屏幕上实时更新日志。ctr+c停止

　　5.3、查看最后100行日志 tail -100 xx.out 

　　5.4、查看关键字附件的日志。如：cat filename | grep -C 5 '关键字'（关键字前后五行。B表示前，A表示后，C表示前后） ----使用不多

　　5.5、还有vi查询啥的。用的也不多。

6、查看端口：（如查看某个端口是否被占用）

　　6.1、netstat -anp | grep 端口号（状态为LISTEN表示被占用）

7、查找文件

　　7.1、查找大小超过xx的文件： find . -type f -size +xxk  -----(find . -type f -mtime -1 -size +100k -size-400k)--查区间大小的文件

　　7.2、通过文件名：find / -name xxxx    ---整个硬盘查找

　　其余的基本上不常用

8、vim（vi）编辑器　　

　　有命令模式、输入模式、末行模式三种模式。
　　命令模式：查找内容(/abc、跳转到指定行(20gg)、跳转到尾行(G)、跳转到首行(gg)、删除行(dd)、插入行(o)、复制粘贴(yy,p)
　　输入模式：编辑文件内容
　　末行模式：保存退出(wq)、强制退出(q!)、显示文件行号(set number)
　　在命令模式下，输入a或i即可切换到输入模式，输入冒号(:)即可切换到末行模式；在输入模式和末行模式下，按esc键切换到命令模式


--Linux和window中进程的区别


--Linux的ping命令实现的原理
他向网络上的另一个主机系统发送ICMP报文，如果指定系统得到了报文，
它将把报文原样传回给发送者，
这有点像潜水艇的声纳系统中使用的发声装置。


--举出是个常用的Linux命令
问题一：

绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？

答案：
绝对路径： 如/etc/init.d
当前目录和上层目录： ./  ../
主目录： ~/
切换目录： cd

问题二：

怎么查看当前进程？怎么执行退出？怎么查看当前路径？
答案：
查看当前进程： ps
执行退出： exit
查看当前路径： pwd

问题三：

怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？
答案：
清屏： clear
退出当前命令： ctrl+c 彻底退出
执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名
查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告诉你一些常用参数； info adduesr；

问题四：

Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？
答案：
ls 执行的功能： 列出指定目录中的目录，以及文件
哪些参数以及区别： a 所有文件l 详细信息，包括大小字节数，可读可写可执行的权限等

问题五：

建立软链接(快捷方式)，以及硬链接的命令。
答案：
软链接： ln -s slink source
硬链接： ln link source

问题六：

目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？
答案：
创建目录： mkdir
创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件
复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？
文件权限修改： chmod
格式如下：

chmodu+xfile给file的属主增加执行权限 chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
chmodu=rwx,g=rx,o=xfile上例的另一种形式 chmod =r file 为所有用户分配读权限
chmod444file同上例 chmod a-wx,a+r file同上例
$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限

 

问题八：

查看文件内容有哪些命令可以使用？
答案：
vi 文件名 #编辑方式查看，可修改
cat 文件名 #显示全部文件内容
more 文件名 #分页显示文件内容
less 文件名 #与 more 相似，更好的是可以往前翻页
tail 文件名 #仅查看尾部，还可以指定行数
head 文件名 #仅查看头部,还可以指定行数

问题九：

随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”? 

答案：

写文件命令：vi

向屏幕输出带空格的字符串:echo hello world

 

问题十：

终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？
答案：
终端  /dev/tty

黑洞文件  /dev/null

问题十一：

移动文件用哪个命令？改名用哪个命令？
答案：
mv mv

问题十二：

复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？
答案：
cp cp -r  ？？？？

问题十三：

删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？
答案：
rm rm -r rmdir

问题十四： 

Linux 下命令有哪几种可使用的通配符？分别代表什么含义?
答案：
“？”可替代单个字符。

“*”可替代任意多个字符。

方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]

 

问题十五：

用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)
答案：

wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。

问题十六：

Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?
答案：
是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。
grep [stringSTRING] filename grep [^string] filename

问题十七：

Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？
答案：
（1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。
（2）、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。
“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。

（3）、就绪状态：在 run_queue 队列里的状态

（4）、运行状态：在 run_queue 队列里的状态
（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起
（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉
（7）、退出状态

D 不可中断 Uninterruptible（usually IO）
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核 2.6 开始无效）
X 死掉的进程

 

问题十八：

怎么使一个命令在后台运行?
答案：
一般都是使用 & 在命令结尾来让程序自动运行。(命令后可以不追加空格)


问题十九：

利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？
答案：
ps -ef (system v 输出) 

ps -aux bsd 格式输出

ps -ef | grep pid

问题二十：

哪个命令专门用来查看后台任务? 

答案：

job -l


问题二十一：

把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?
答案：
把后台任务调到前台执行 fg

把停下的后台任务在后台执行起来 bg

 

问题二十二：

终止进程用什么命令? 带什么参数? 

答案：

kill [-s <信息名称或编号>][程序] 或 kill [-l <信息编号>] 

kill-9 pid

 

问题二十三：

怎么查看系统支持的所有信号？

答案：

kill -l

问题二十四：

搜索文件用什么命令? 格式是怎么样的? 

答案：

find <指定目录> <指定条件> <指定动作>

whereis 加参数与文件名

locate 只加文件名

find 直接搜索磁盘，较慢。

find / -name "string*"

 

问题二十五：

查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?
答案：
查找自己所在的终端信息：who am i

查看当前谁在使用该主机：who

 

问题二十六：

使用什么命令查看用过的命令列表?

答案：

history


问题二十七：

使用什么命令查看磁盘使用空间？ 空闲空间呢?

答案：

df -hl
文件系统 容量 已用 可用 已用% 挂载点
Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /
/dev/hda1 494M 19M 450M 4% /boot

问题二十八：

使用什么命令查看网络是否连通?
答案：
netstat

问题二十九：

使用什么命令查看 ip 地址及接口信息？

答案：

ifconfig

问题三十：

查看各类环境变量用什么命令?

答案：

查看所有 env
查看某个，如 home： env $HOME

问题三十一：

通过什么命令指定命令提示符?

答案：

\u：显示当前用户账号

\h：显示当前主机名

\W：只显示当前路径最后一个目录

\w：显示当前绝对路径（当前用户目录会以~代替）

$PWD：显示当前全路径

$：显示命令行’$'或者’#'符号

\#：下达的第几个命令

\d：代表日期，格式为week day month date，例如："MonAug1"

\t：显示时间为24小时格式，如：HH：MM：SS

\T：显示时间为12小时格式

\A：显示时间为24小时格式：HH：MM

\v：BASH的版本信息 如export PS1=’[\u@\h\w\#]$‘

 

问题三十二：

查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加? 

答案：

whereis [-bfmsu][-B <目录>...][-M <目录>...][-S <目录>...][文件...]

补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。

-b   只查找二进制文件。

-B<目录> 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。
-m   只查找说明文件。
-M<目录> 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。
-S<目录> 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。
which 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。
-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。
-V   显示版本信息

 

问题三十三：

通过什么命令查找执行命令?
答案：
which 只能查可执行文件

whereis 只能查二进制文件、说明文档，源文件等


问题三十四：

怎么对命令进行取别名？
答案：
alias la='ls -a'

问题三十五：

du 和 df 的定义，以及区别？
答案：

du 显示目录或文件的大小

df 显示每个<文件>所在的文件系统的信息，默认是显示所有文件系统。
（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。
df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。

问题三十六：

awk 详解。
答案：

awk '{pattern + action}' {filenames}
#cat /etc/passwd |awk -F ':' '{print 1"\t"7}' //-F 的意思是以':'分隔 root /bin/bash
daemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行

#awk -F: '/root/' /etc/passwd root:x:0:0:root:/root:/bin/bash

 

问题三十七：

当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？

答案：

可以使用bind命令，bind可以很方便地在shell中实现宏或按键的绑定。

在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。

比如获取F12的字符序列获取方法如下：先按下Ctrl+V,然后按下F12 .我们就可以得到F12的字符序列 ^[[24~。

接着使用bind进行绑定。

[root@localhost ~]# bind ‘”\e[24~":"date"'

注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。

【附】也可以使用showkey -a命令查看按键对应的字符序列。

 

问题三十八：

如果一个linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？

答案：

使用命令compgen ­-c，可以打印出所有支持的命令列表。

[root@localhost ~]$ compgen -c

l.

ll

ls

which

if

then

else

elif

fi

case

esac

for

select

while

until

do

done

…

 

问题三十九：

如果你的助手想要打印出当前的目录栈，你会建议他怎么做？

答案：

使用Linux 命令dirs可以将当前的目录栈打印出来。

[root@localhost ~]# dirs

/usr/share/X11

【附】：目录栈通过pushd popd 来操作。

 

问题四十：

你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？

答案：

使用linux命令 ’disown -r ’可以将所有正在运行的进程移除。

 

问题四十一：

bash shell 中的hash 命令有什么作用？

答案：

linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。

[root@localhost ~]# hash

hits command

2 /bin/ls

2 /bin/su

 

问题四十二：

哪一个bash内置命令能够进行数学运算。

答案：

bash shell 的内置命令let 可以进行整型数的数学运算。

#! /bin/bash
…
…
let c=a+b
…
…

 

问题四十三：

怎样一页一页地查看一个大文件的内容呢？

答案：

通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.

[root@localhost ~]# cat file_name.txt | more

 

问题四十四：

数据字典属于哪一个用户的？

答案：

数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的

 

问题四十五：

怎样查看一个linux命令的概要与用法？假设你在/bin目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？

答案：

使用命令whatis 可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat 去查看‘zcat’的介绍以及使用简要。

[root@localhost ~]# whatis zcat

zcat [gzip] (1) – compress or expand files

 

问题四十六：

使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？

答案：

使用命令repquota 能够显示出一个文件系统的配额信息

【附】只有root用户才能够查看其它用户的配额。
--如何查看端口


*深浅拷贝


*自省
--在程序运行中判断数据类型




*read,readline和readlines
    read 读取整个文件
    readline 读取下一行,使用生成器方法
    readlines 读取整个文件到一个迭代器以供我们遍历（读取大文件占内存）


*python2和python3区别
    http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/


*super().__init__() 用法






*数据库
--MySQL语句的编写
MySQL中的左连接和右连接、内连接的区别

MySQL的ACID



MySQL底层的B+树
https://blog.csdn.net/majiawenzzz/article/details/81098870

MySQL的三个范式


MySQL的数据库优化


Redis简介


Redis支持的数据结构


Redis数据淘汰策略


Redis去重策略


Redis持久化


哈希表、红黑树、二叉搜索树、B树、2,3树的基本概念要讲的出来



--事务
    事务(Transaction)，一般是指要做的或所做的事情。
    在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。
    在计算机术语中，事务通常就是指数据库事务。
    
    一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：

    1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
    2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
 
--事务隔离级别
    数据库中，事务是要满足ACID的，即原子性，一致性，持久性，隔离性
    在ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级
    
    不同的隔离级别会导致不同的读现象
    
    *脏读
        即读取无效数据。当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交（commit）到数据库中，这时，另一个事务也访问这个数据（看到的是修改后的数据，但是还没有保存）
        然后使用了这个数据
        因为这个数据是还没有提交的数据，那么另一个事务读到这个数据是脏数据（因为数据可能会修改），依据脏数据所做的操作可能是不正确的。
        
        ////如何解决脏读？
            写的时候加锁
    
    *不可重复读
        指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询系统中的其他事物修改的提交而引起的。比如事物T1读取某一数据，事物T2读取并修改了该数据，T1为了对
        读取值进行检验而再次读取该数据，得到了不同结果
        
        ////如何解决不可重复读？
            读的时候加锁
    *幻读
        指同一个事物内多次查询返回的结果集不一样（比如增加了或者减少了行记录）比如同一个事物A内第一次查询的时候有n
        条记录，但是第二次同等条件下查询又是n+1条记录，这就好像产生了幻觉，是不可重复读的特殊场景

        ////如何解决幻读？
             串行化

--乐观锁悲观锁

    *悲观锁
        当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁防止并发，是一种并发控制
        先取锁再访问
        
        --实现
            往往依靠数据库提供的锁机制
            在对记录进行修改前，先尝试为该记录加上排它锁
            如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常
            如果成功加锁，那么就可以对记录做修改，事物完成后就会解锁了
            期间如果有其他对该记录做修改或加排它锁的操作，都会等待我们解锁或者直接抛出异常
            
            在mysql中，要使用悲观锁，必须关闭自动提交属性（set autocommit=0）
            
            begin;//开启事务
            select name from items where id=1 for update;//加锁
            update items set name='dd' where id=1;
            commit;//关闭事务
            
            !!!
            mysql InnoDB默认行级锁，行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住
          
            
    
    *乐观锁
        是相对悲观锁而言的，假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候才会对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误信息，让用户决定如何去做
        不会使用数据库提供的锁机制，一般乐观锁实现的方式就是记录数据版本
        在提交的时候采取锁定，所以不会产生任何锁和死锁
        
        --实现
            主要是两个步骤：冲突检测和数据更新Compare and Swap（CAS）
            当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试
            //查询出商品库存信息,quantity=3
            select quantity from items where id=1;
            //修改商品库存为2
            update items set quantity=2 where id=1 and quantity=3;
            在更新之前先查询一下库存表中当前库存数，在做update时，以库存数作为一个修改条件，当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行
            比较，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据
            一旦发生高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败，可以减少乐观锁的粒度
            update items set quantity=quantity-1 where id=1 and quantity-1>0
            如果用户下单数为1，则通过quantity-1>0的方式进行乐观锁控制
            

*Git和Svn区别
--  Git是分布式的，Svn是集中式
    Git把内容按元数据方式存储，SVN是文件
    Git分支与Svn不同
    Git没有一个全局的版本号
    Git内容完整性要优于svn，Git的内容存储使用的是SHA-1哈希算法，这能确保代码内容的完整性
*git checkout的作用

*常见面试题

https://segmentfault.com/a/1190000019315509
https://cloud.tencent.com/developer/article/1404019

*常用的命令清单



*算法相关
--斐波那契数列
    方法一：
    def fib(n):
        if n<2:
            return 1
        else:
            return fib(n-1) + fib(n-2)
    
    方法二：
    def fib(n):
        f1 = f2 = 1
        for k in range(1,n):
            f1,f2 = f2,f1+f2    # 涉及解包知识，当等式赋值时，先计算右边表达式，再按顺序解包
        return f2



*网络相关

--TCP与UDP区别总结：
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

--TCP如何实现可靠传输：

应用数据被分割成 TCP 认为最适合发送的数据块。
TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
TCP 的接收端会丢弃重复的数据。

流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

拥塞控制： 当网络拥塞时，减少数据的发送。

停止等待协议: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。 
超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。







--TCP是如何保证报文有序的
（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； 

（2）并为每个已发送的数据包启动一个超时定时器； 

（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区; 

（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。

（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

--ARQ协议
ARQ协议也就是超时重传机制。通过确认和超时机制保证了数据的正确到达。ARQ协议包括停止等待ARQ和连续ARQ

停止等待ARQ:
只要A向B发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对应端应答就取消定时器并发送下一段报文，若ACK超时或丢失，超过定时器
事件A端照样会重传报文，这时候B端收到相同序号的报文会丢弃该报文并重传应答，知道A 端发送下一个序号的报文
这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的ACK

连续ARQ:
在连续ARQ中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待ARQ协议来说减少了等待时间

累计确认：
可以在收到多个报文以后统一回复一个应答报文，报文中的ACK可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号+1的数据

滑动窗口：
发送端窗口包含已发送但为收到应答的数据和可以发送确没发送的数据
发送端的窗口是由接收窗口剩余大小决定的，接收方会把当前接收窗口剩余大小写入应答报文，发送端收到应答后，根据该值和当前网络拥塞情况设置发送窗口大小，所以发送窗口的大小时不断变化的
滑动窗口实现了流量控制


--拥塞处理
拥塞处理和流量控制不一样，后者是作用于接收方，保证接收方来得及接收数据，而前者式作用域网络，放置过多的数据拥塞网络，避免出现网络负载过大的情况
慢开始：
    就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞
    步骤：1.连接初始设置拥塞窗口cwns为1MSS
          2.每过一个RTT就将窗口大小乘2
          3.指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法
拥塞避免：
在传输过程中可能定时器超时的情况，这时TCP会认为网络拥塞了，会马上进行以下步骤：
    将阈值设置为当前拥塞窗口的一半
    将拥塞窗口设为1MSS
    启动拥塞避免算法
每过一个RTT窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值

快速重传：
快速重传一般和快速恢复一起出现，一旦接收端收到的报文出现失序情况，接收端只会回复最后一个顺序正确的报文序号（没有SACK的情况下）如果收到三个重复的ACK，无需等待定时器超时
再重发而是启动快速重传


--UDP如何设计可靠传输
最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

1、添加seq/ack机制，确保数据发送到对端
2、添加发送和接收缓冲区，主要是用户超时重传。
3、添加超时重传机制。





--ARP协议

地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；
收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

--HTTP协议与HTTP1.1以及HTTP2.0的区别
HTTP是一个无状态协议

--HTTP头部字段有哪些

--HTTPS的加密过程
    通过TLS协议进行加密
    TLS:
        TLS位于传输层之上，应用层之下，首次进行TLS协议传输需要两个RTT，接下来可以通过Session Resumption减少到一个RTT
        在TLS中使用了两种加密技术：对称加密和非对称加密
        对称加密：
            就是两边拥有相同的秘钥，两边都知道如何将密文加密解密
        非对称加密：
            有公钥和私钥之分，公钥所有人都可以知道，可以将数据解密必须使用秘钥解密，私钥只有分发公钥的一方才知道
        TLS握手过程：
            1.客户端发送一个随机值，需要的协议和加密方式
            2.服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书
            3.客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过读物的证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
            4.服务端收到加密过的随机值并使用私钥解密获得第三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥来加密解密
        在TLS握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信



简述http请求的7个步骤
1、	建立TCP连接
2、	Web浏览器发送请命令
3、	Web浏览器发送请求头信息
4、	Web服务器应答,(应答第一部分是协议的版本号和应答状态码)
5、	Web服务器向浏览器发送应答头信息（发送被请求的文档和自己的数据）
6、	Web服务器向浏览器发送数据（发送头信息后，会发送一个空白行来表示头信息的发送到此结束，接着就以Content-Type应答头信息描述的格式发送用户请求的实际数据）
7、	Web服务器关闭TCP连接

注： 一般情况是，服务器在发送数据之后就会关闭TCP连接，然后如果浏览器或者服务器在其头部信息加入 Connection:keep-alive TCP连接在发送后仍然保持打开状态，
于是，浏览器可以通过想用的链接发送请求，节省新建立连接所需时间，节省带宽。





--csrf,xss,sql注入原理及防范
1.XSS
分类：
     1.反射型：给用户发送页面或者链接，让用户点击来进行攻击
     2.存储型：把攻击存放在服务端，可能造成传播（比如博客系统，每个访问该页面的人都有可能被攻击），主动性更强
     3.DOM型：本质上是反射型，但是是通过用户点击，修改原本dom元素的属性，构造攻击动作
反射型和dom型区别：
     反射型是构造好了攻击动作，然后就等你打开那个页面；dom型也是等你点击，但是不是页面，通过用户动作，把原来的动作注释掉，然后加上自己修改的动作。
XSS作用：
     1.可以获得cookie
     2.仿造get、post请求做一些动作
     3.获得用户的IP
     4.识别用户软件、浏览器
     5.通过钓鱼也可以骗到用户的用户名和密码这样
XSS的防范：
1.对于截取cookie这样的操作可以在cookie上加上HttpOnly，这样js就不能访问cookie了。对于重要的cookie可以考虑加上该设置。
2.输入检查。一般是查询特殊字符，比如『<』,『>』，『、』这样，可以选择对输入进行编码，或者是筛选掉这些字符。
2.没有绝对可以防止XSS攻击的方法，因为XSS比较灵活，任何语言或者框架设计不当都有可能存在漏洞


2.CSRF
总的来说，它就是利用cookie，来盗取用户权限，从此进行操作。
cookie有session和locale两种。前者是临时的，会话关闭之后就没有了，后者是保存在本地的，当缓存过期之后才消失。如果要获取cookie，在IE6，7，8，Safari中会拦截，不让发送本地的缓存。但是在火狐，chrome上就不会拦截。

防御方法：
1.验证码。由于CSRF的攻击点在于浏览器分不清是用户发送的数据还是攻击者发送的数据，所以每次提交重要信息都要求输入验证码，这样可以保证信息是安全的。
2.服务器随机生成一个token发送，这样在请求中的cookie中要是有匹配的token，就认为是安全的请求，否则就可能有安全问题。但是token要建立在没有XSS漏洞的基础上，如果有XSS漏洞，那么攻击者通过获得页面，同样可以从cookie中获得token然后进行模拟操作。
3.用referer。确保请求是来自允许的页面…然而我觉得这个头是可以伪造的…并且服务器并不是都能取到referer头部（由于浏览器隐私保护策略），所以并不是很认同这种方式

3.SQL注入
SQL注入是通过猜测后台查询数据库的语句和数据库的情况，然后后台把用户输入的查询当做查询的一部分来查询数据库，如果构造得当，改变了SQL语句，就可以获得数据库内容甚至权限等等。
防御：
1.使用预编译语句或者存储过程，这样攻击者不能改变SQL语句的结构，就不能擅自查询了。预编译绑定变量，比如SQL语句变量用？表示，这样就无法改变原语句结构了。存储过程没有预编译那么安全，它是把要查询的过程（语句）先存储在数据库，还是有可能存在注入，所以要注意过程中尽量避免使用动态的SQL语句
2.检查输入的数据类型。比如只能是整型这样，这种方式可以很大程度上对抗注入
3.使用安全的函数。对输入进行安全编码后使用
4.注重数据库的权限放行。对于root权限的使用要很注意，遵循『最小权限原则』


*****************XSS和CSRF的区别（from：http://www.cnblogs.com/easytools/archive/2012/06/01/2529350.html）****************************
大家对于这2个攻击可能比较混淆，因为从名字上就很容易混淆，csrf跨站点伪装请求和xss跨站点攻击。

我一开始也对这两个东西搞混淆了，后面发现他们的最根本区别。

CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼。如用户当前已经登录了邮箱，或bbs，同时用户又在使用另外一个，已经被你控制的站点，我们姑且叫它钓鱼网站。这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，构造一个bbs发帖的请求，去往你的bbs发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情。

预防措施，请求中加入随机数，让钓鱼网站无法正常伪造请求。

XSS攻击的主要目的则是，想办法获取目标攻击网站的cookie，因为有了cookie相当于有了seesion，有了这些信息就可以在任意能接进互联网的pc登陆该网站，并以其他人的生份登陆，做一些破坏。

预防措施，防止下发界面显示html标签，把</>等符号转义


--token，session，cookie应用与区别




--HTTP状态码有哪些
    1xx：指示信息–表示请求已接收，继续处理 
    2xx：成功–表示请求已被成功接收、理解、接受 
    3xx：重定向–要完成请求必须进行更进一步的操作
    4xx：客户端错误–请求有语法错误或请求无法实现
    5xx：服务器端错误–服务器未能实现合法的请求 
    常见状态代码、状态描述、说明： 
    200：请求被正常处理
    204：请求被受理但没有资源可以返回
    206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
    301：永久性重定向
    302：临时重定向
    303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
    304：发送附带条件的请求时，条件不满足时返回，与重定向无关
    307：临时重定向，与302类似，只是强制要求使用POST方法
    400：请求报文语法有误，服务器无法识别
    401：请求需要认证
    403：请求的对应资源禁止被访问
    404：服务器无法找到对应资源
    500：服务器内部错误
    503：服务器正忙


--HTTP请求的方式
1   GET	请求指定的页面信息，并返回实体主体。
2	HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3	POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
4	PUT	从客户端向服务器传送的数据取代指定的文档的内容。
5	DELETE	请求服务器删除指定的页面。
6	CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7	OPTIONS	允许客户端查看服务器的性能。
8	TRACE	回显服务器收到的请求，主要用于测试或诊断。
9	PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新 。



--三次握手
    刚开始，客户端处于Closed状态，服务器处于Listen状态
    第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN（c），此时客户端处于SYN_Send状态
    第二次握手：服务器收到客户端的SYN报文之后，回忆自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN（s）
    同时会把客户端的ISN+1作为Ack的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD状态
    第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于established状态
    服务器收到ACK报文之后，也处于establised状态，此时，双方已建立起了连接，这次握手能够携带数据
    
    三次握手的作用：
    确认双方的收发能力正常
    制定自己的初始化序列号，为后面的可靠传送做准备
    如果是HTTPS协议的话，三次握手这个过程还会进行数字证书的验证以及加密秘钥的生成
    
    
    其他问题：
    1·ISN是固定的吗？
        三次握手的一个重要功能是客户端和服务端交换ISN（Initial Sequence Number），以方便让对方知道接下来接收数据的时候如何按序列号组装数据
        如果ISN是固定的，攻击者很容易猜出后续的确认好，因此ISN是动态生成的
        
    2·什么是半连接队列
        服务器第一次收到客户端的SYN之后，就会处于SYN_REVD状态，此时双方还没有完全建立其连接，服务器会把这种状态下请求连接放在一个队列里，我们把这种对列称为半连接队列
        当然还有全连接队列，就是已经完成三次握手，，如果队列满了，就会出现丢包现象

--四次挥手
    刚开始双方处于established状态，假如是客户端先发起关闭请求
    第一次挥手：客户端发送一个FIN=1报文，报文中会指定一个序列号seq=u（最后一次传送数据最后一个字节的序号+1），此时客户端处于FIN_WAIT1状态
    第二次握手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为报文的确认号值，表明已经收到客户端的报文了，并带上自己的序列号seq=v，此时服务端处于CLOSE_WAIT状态
    第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，指定一个序列号seq=w，发送一个确认号（seq=u+1）此时服务端处于LAST_ACK状态
    第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务端的序列号值+1作为自己报文的确认号值，此时客户端处于TIME_WAIT状态
    客户端需要过一阵子（2**MSL：最长报文段寿命）以确保服务端收到自己的ACK报文之后才会进入CLOSED状态
    服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态
    
--面试题（微信收藏）

    序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文
    指派一个序号；序列号seq就是这个报文段中第一个字节的数据编号
    
    确认号ack:占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号值得是期望收到下一个字节的编号；
    因此当前报文段最后一个字节的编号+1为确认号
    
    确认ACK：占1位，仅当ACK=1时，确认号字段才有效，ACK=0时，确认号无效
    
    同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示；这是一个连接请求报文段。若同意连接，则在响应报文段使得SYN=1,ACK=1,因此，SYN=1表示这是一个连接请求，或
    连接接受报文。SYN这个标志位只有在TCP产生连接时才会被置一，握手完成后SYN标志位被置0
    
    终止FIN:用来释放一个连接。FIN=1表示此报文段的发送方的数据已经发送完毕，并要求释放运输的连接


    为什么连接的时候是三次握手，关闭的时候确是四次握手？
        因为当SERVER端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文是用来同步的。但是当关闭连接时，当SERVER端收到FIN报文时，
        很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，你发的FIN报文我收到了。只有等到我SERVER端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送
        故需要四次挥手
    
    为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回CLOSE装填？
        我们必须假设网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发出最后的ACK回复，但该ACK可能丢失。SERVER如果没有收到
        ACK，将不断发送FIN片段，所以Client不能直接关闭，它必须确认SERVER收到了该ACK，会进入TIME_WAIT状态，如果在该时间再次收到FIN，那么Client会重新发送ACK，再等待2MSL
     
    为什么不能用两次握手进行连接？
        三次握手有两个重要的功能，既要双方做好发送数据的准备工作（双方都知道彼此已准备好），也要允许双方就初始序列号进行协商，这个序列号就在这握手过程中被发送和确认
        现在把三次握手改成两次，可能发生死锁。假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定S认为连接已经成功的建立了，可以开始
        发送数据分组。可是，S的应答分组在传输中有丢失的可能，C将不知道S是否已准备好，不知道S建立了怎么样的序列号，甚至不知道S是否收到自己的连接请求分组，在这种情况下，
        C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出分组超时后，重新发送同样的分组，这样就形成了死锁。
    
    如果已经建立连接，但是客户端突然出现故障了怎么办？
        TCP设有一个保活计时器，显然客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为2小时，
        若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没有反应，服务器就认为客户端出现了故障，接着就关闭连接
        
        
        


--GET,POST区别（微信收藏）
    GET能请求缓存，POST不能
    GET,POST没有本质上的区别，只是报文格式不同
    GET和POST只是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的应用层协议，无论GET,POST，用的都是同一个传输层协议，所以在传输上没有区别
    报文格式上，不带参数时，最大区别就是第一行方法名不同
    约定中，GET的参数放在url中，POST方法参数放在body中
    HTTP协议没有Body和URL的长度限制，对URL限制的大多是浏览器和服务器的原因
    有的浏览器会将POST的header和body分开发送

--常见状态码


--从输入URL到页面加载完成的过程
1.先做DNS查询（将url通过DNS服务器解析成ip地址），如果这一步做了只能DNS解析的话，会提供访问速度最快的IP地址回来服务解析成ip地址
2.接下来是TCP握手，应用层会下发数据给传输层，这里TCP协议会指明两端的端口号，然后下发给网络层，
网络层中的IP协议会确定IP地址，并指明了数据传输中如何跳转路由器，然后包会封装到数据链路层的数据帧结构中。
最后就是物理层面的传输了
3.TCP握手后会进行TLS握手，然后开始正式传输数据
4.数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多个服务器上
这时假设服务端会响应一个html文件
5.首先浏览器会判断状态码是什么，如果是200那就继续解析，如果400或500的话就会报错，如果300就会重定向
这里会有一个重定向计数器，避免过多次的重定向，超过次数也会报错
6.浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
7.文件解码成功后会正式开始渲染流程，先根据HTML构建DOM树，有CSS的话会去构建CSSOM树。
如果遇到script标签的话，会判断是否存在async或者defer，前者会并行进行下载并执行JS，后者会先下载文件，
然后等待HTML解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程指导JS执行完毕。遇到文件下咋子
的会去下载文件，如果使用HTTP2.0协议的话会极大的提高多图的下载效率
8.初始的HTML被完全加载和解析后会触发DOMContentLoaded事件
9.CSSOM树和DOM树构建完成后会开始生成Render树，这一步就是确定页面元素的布局，样式等等诸多方面的东西
10.在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了



--Nginx
    Nginx是一款轻量级的Web服务器，反向代理服务器及电子邮件（IMAP/POP3）代理服务器
        什么是反向代理？
            反向代理方式实质以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的解惑返回给internet上请求连接的客户端
            此时代理服务器对外表现为一个反向代理服务器



算法刷题记录

----题3：

a[i], a[a[i]] = a[a[i]], a[i] 和 a[a[i]], a[i] = a[i], a[a[i]]区别：前者会进入死循环
答案：
改变数组的做法：
    def v(arr):
        for i in range(0,len(arr)):
            while a[i] != i:
                if arr[arr[i]] == arr[i]:
                    return arr[i]
                else:
                    a[a[i]], a[i] = a[i], a[a[i]]

不改变数组的做法：
利用二分性质：
    def Solution(arr):
        start = 0
        end = len(arr) - 1
        while start <= end:
            middle = (end + start) // 2
            c = count(arr,start,middle)
            if end == start:
                if c > 1:
                    return end
                else:
                    break
            if c > middle-start+1:# 这一步非常重要，在这一步卡了很久一开始写的条件是middle+1，因为忽略了如果在右侧出现重复的情况，这里的判断条件是为了确定区间里的数字比如[2,3]有两个数字
                end = middle
            else:
                start = middle + 1
    def count(arr,start,end):
        c = 0
        for i in arr:
            if i in range(start,end+1):
                c += 1
        return c

----题4：
    def solution(arr,ret):
        row = len(arr)
        col = len(arr[0])
        i, j = 0, col - 1
        while i < row and j > 0:
            if arr[i][j] == ret:
                return True
            elif arr[i][j] < ret:
                i += 1
            else:
                j -= 1
        return False


----题5：
Python中字符串是不可变类型，所以只能借助新列表来完成
def solution(s):
    p1 = len(s) - 1
    n = s.count(' ')
    s += [0] * n * 2   # 扩充列表，一个空格，扩充两个
    while p1!= p2:
        if s[p1] == ' ':
            s[p2-2] = '%'
            s[p2-1] = '2'
            s[p2] = '0'
            p2 -= 3
        else:
            s[p2] = s[p1]
            p2 -= 1
        p1 -= 1
    return ''.join(s)       # 还原为字符串


-----题6：
先实现链表的反转，再打印
或者将链表的元素存入栈，然后逐个弹出（此方法略）
    class LNode:
        def __init__(self,elem,next_=None):
            self.elem = elem
            self.next = next_


    class LList:
        def __init__(self):
            self.head = None

        def is_empty(self):
            return self.head is None

        def prepend(self,elem):
            self.head = LNode(elem,self.head)

        def pop(self):
            if self.head is None:
                raise Exception
            e = self.head.elem
            self.head = self.head.next
            return e

        def append(self,elem):
            if self.head is None:
                self.head = LNode(elem)
                return
            p = self.head
            while p.next is not None:
                p = p.next
            p.next = LNode(elem)

        def printall(self):
            p = self.head
            while p is not None:
                print(p.elem)
                p = p.next

        def reverse(self):
            L, M, R = None, None, self.head
            while R.next is not None:
                L = M
                M = R
                R = R.next
                M.next = L
            R.next = M
            self.head = R


------题7：




-----题17：还需理解
class Solution:
    def Print1ToMaxOfNDigits(self, n):
        if n <= 0:
            return
        number = ['0'] * n  # 用数组来表示[‘0’，‘0’~~]
        for i in range(10):
            number[0] = str(i)  # 依次取0-9的值，第一位
            self.Print1ToMaxOfNDigitsRecursively(number, n, 0)  # 第一次调用递归函数

    def PrintNumber(self, number):  # 输出数字
        # 此处的number为一个str类型的数组，每个数组元素是一个0-9之间数字的字符串形式
        isBeginning0 = True
        nLength = len(number)
        for i in range(nLength):
            if isBeginning0 and number[i] != '0':  # 只输出非零项
                isBeginning0 = False
            if not isBeginning0:
                print('%c' % number[i],end='')
                import time
                time.sleep(2)
        print('\t')

    def Print1ToMaxOfNDigitsRecursively(self, number, length, index):  # index表示变换位数
        if index == length - 1:  # 最后一位
            self.PrintNumber(number)
            return
        for i in range(10):
            number[index + 1] = str(i)  # 改变下一位
            self.Print1ToMaxOfNDigitsRecursively(number, length, index + 1)  # 递归调用
            


------题18

O(1)时间删除节点
class Lnode():
    def __init__(self,num,next_=None):
        self.num = num
        self.next = next_

class Solution:
    @classmethod
    def del_node(self,head,node):
        if head == node:
            del head
        if node.next == None:
            while head:
                if head.next == node:
                    head.next = None
                head = head.next
        else:
            node.num = node.next.num
            node.next = node.next.next
n1 = Lnode(1)
b = Lnode(2)    # 这里用b是为了后面删除的时候指定特定的节点
n1.next = b 
n1.next.next=Lnode(3)      


删除重复节点：
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    @classmethod
    def deleteDuplication(self, pHead):
        # 第一步先检测一下是不是空的或者是不是只有一个
        if pHead is None or pHead.next is None:
            return pHead
        # 第二步因为防止第一个就是重复的节点，所以创作一个新的头节点。
        first = ListNode(-1)
        # 因为需要两个指针，一个指着重复结点上一个结点，一个指着重复结点后一个值。
        first.next = pHead
        last = first
        while pHead and pHead.next:
            if pHead.val == pHead.next.val:
                val = pHead.val
                while pHead and val == pHead.val:
                    pHead = pHead.next
                last.next = pHead
            else:
                last = pHead
                pHead = pHead.next
        return first.next





--------题19




--------题22：倒数第k个节点
    class Lnode:
        def __init__(self,val,next_=None):
            self.val = val
            self.next = next_


    def solution(node,k):
        if k == 0:
            return False
        if not node.val:
            return False

        count = 1
        check = node
        while node.next is not None:
            node = node.next
            count += 1
            if count > k:
                check = check.next
        if count < k:
            return False
        return check.val



-----题24：反转链表










